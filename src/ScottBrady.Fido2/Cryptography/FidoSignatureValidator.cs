using System;
using System.Security.Cryptography;
using System.Threading.Tasks;
using Microsoft.Extensions.Options;
using ScottBrady.Fido2.Models;

namespace ScottBrady.Fido2.Cryptography;

/// <summary>
/// FIDO signature validator.
/// </summary>
public interface IFidoSignatureValidator
{
    /// <summary>
    /// Validates a signature generated by a FIDO authenticator.
    /// </summary>
    /// <param name="response">The original response from the FIDO authenticator including the clientDataJSON, authenticatorData, and signature.</param>
    /// <param name="key">The stored public key.</param>
    Task<bool> HasValidSignature(AuthenticatorAssertionResponse response, CredentialPublicKey key);
}

/// <inheritdoc />
public class FidoSignatureValidator : IFidoSignatureValidator
{
    private readonly FidoOptions options;

    /// <summary>
    /// Creates a new FidoSignatureValidator.
    /// </summary>
    /// <param name="options"></param>
    public FidoSignatureValidator(IOptions<FidoOptions> options)
    {
        if (options == null) throw new ArgumentNullException(nameof(options));
        this.options = options.Value;
    }
    
    /// <inheritdoc />
    public Task<bool> HasValidSignature(AuthenticatorAssertionResponse response, CredentialPublicKey key)
    {
        if (response == null) throw new ArgumentNullException(nameof(response));
        if (key == null) throw new ArgumentNullException(nameof(key));
        
        var data = ParseData(response.ClientDataJson, response.AuthenticatorData);

        if (!options.SigningAlgorithmStrategies.TryGetValue(key.Algorithm, out var strategy)) throw new FidoException($"Unsupported COSE algorithm of {key.Algorithm}");

        var isValid = strategy().IsValidSignature(data, response.Signature, key);
        return Task.FromResult(isValid);
    }

    /// <summary>
    /// Prepares the data to verify to <a href="https://www.w3.org/TR/webauthn-2/#sctn-verifying-assertion">verify an authentication assertion</a>.
    /// </summary>
    /// <returns>A binary concatenation of sha256(clientDataJSON) and authenticatorData</returns>
    private static byte[] ParseData(byte[] clientDataJson, byte[] authenticatorData)
    {
        if (clientDataJson == null) throw new ArgumentNullException(nameof(clientDataJson));
        if (authenticatorData == null) throw new ArgumentNullException(nameof(authenticatorData));
        
        var hash = SHA256.HashData(clientDataJson);
        var data = new byte[authenticatorData.Length + hash.Length];
        authenticatorData.CopyTo(data, 0);
        hash.CopyTo(data, authenticatorData.Length);

        return data;
    }
}
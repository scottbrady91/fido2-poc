using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Security.Cryptography;
using System.Threading.Tasks;
using ScottBrady.Fido2.Models;

namespace ScottBrady.Fido2.Cryptography;

/// <summary>
/// FIDO signature validator.
/// </summary>
public interface IFidoSignatureValidator
{
    /// <summary>
    /// Validates a signature generated by a FIDO authenticator.
    /// </summary>
    /// <param name="response">The original response from the FIDO authenticator including the clientDataJSON, authenticatorData, and signature.</param>
    /// <param name="key">The stored public key.</param>
    Task<bool> HasValidSignature(AuthenticatorAssertionResponse response, CredentialPublicKey key);
}

/// <inheritdoc />
public class FidoSignatureValidator : IFidoSignatureValidator
{
    // TODO: how to make extensible? Move to options? Move to factory?
    private readonly IReadOnlyDictionary<string, Func<ISignatureValidationStrategy>> validators =
        new ReadOnlyDictionary<string, Func<ISignatureValidationStrategy>>(new Dictionary<string, Func<ISignatureValidationStrategy>>
        {
            { CoseConstants.Algorithms.ES256, () => new EcdsaSignatureValidationStrategy() },
            { CoseConstants.Algorithms.ES384, () => new EcdsaSignatureValidationStrategy() },
            { CoseConstants.Algorithms.ES512, () => new EcdsaSignatureValidationStrategy() },
            { CoseConstants.Algorithms.RS256, () => new RsaSignatureValidationStrategy() },
            { CoseConstants.Algorithms.RS384, () => new RsaSignatureValidationStrategy() },
            { CoseConstants.Algorithms.RS512, () => new RsaSignatureValidationStrategy() }
            // TODO: RS1?
            // TODO: EdDSA?
        });

    /// <inheritdoc />
    public Task<bool> HasValidSignature(AuthenticatorAssertionResponse response, CredentialPublicKey key)
    {
        if (response == null) throw new ArgumentNullException(nameof(response));
        if (key == null) throw new ArgumentNullException(nameof(key));
        
        var data = ParseData(response.ClientDataJson, response.AuthenticatorData);

        if (!validators.TryGetValue(key.Algorithm, out var strategy)) throw new FidoException($"Unsupported COSE algorithm of {key.Algorithm}");

        var isValid = strategy().IsValidSignature(data, response.Signature, key);
        return Task.FromResult(isValid);
    }

    /// <summary>
    /// Prepares the data to verify to <a href="https://www.w3.org/TR/webauthn-2/#sctn-verifying-assertion">verify an authentication assertion</a>.
    /// </summary>
    /// <returns>A binary concatenation of sha256(clientDataJSON) and authenticatorData</returns>
    private static byte[] ParseData(byte[] clientDataJson, byte[] authenticatorData)
    {
        if (clientDataJson == null) throw new ArgumentNullException(nameof(clientDataJson));
        if (authenticatorData == null) throw new ArgumentNullException(nameof(authenticatorData));
        
        var hash = SHA256.HashData(clientDataJson);
        var data = new byte[authenticatorData.Length + hash.Length];
        authenticatorData.CopyTo(data, 0);
        hash.CopyTo(data, authenticatorData.Length);

        return data;
    }
}